## 题目描述
给定一个整数数组`nums`和一个整数目标值`target`，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

__示例1：__
> 输入：nums = [2, 7, 11, 15], target = 9  
> 输出：[0, 1]  
> 解释：因为nums[0] + num[1] == 9，返回[0, 1]。

__示例2：__
> 输入：nums = [3, 2, 4], target = 6  
> 输出：[1, 2]

__示例3：__
> 输入：nums = [3, 3], target = 6  
> 输出：[0, 1] 

## 题目分析
这道题要求找到数组中的两个元素，使其和等于目标值。最简单的方法就是暴力搜索，然而结果是Time Limit Exceeded，其时间复杂度为$O(n^2)$。因此，需要一个时间复杂度为$O(n)$的算法来实现。

我们需要在线性的时间复杂度情况下的算法，那么只能遍历一次数组，在处理一个元素时，另一个元素则需要将其存储起来。这里是一个时空平衡的情况，用空间复杂度来换取暴力搜索的时间复杂度。

我们使用`HashMap`来建立数组元素和其坐标之间的映射。`HashMap`是常数级的查找效率，在遍历数组时，用`target`减去遍历到的数字，就是另一个需要的数字了，直接在`HashMap`中查找其是否存在即可。
__注意__，要判断查找的数字不是第一个数字。

以示例二为例：`nums = [3, 2, 4], target = 6`  
在遍历数组时，一边查找HashMap中是否存在`target - nums[i]`，一边建立HashMap，图解如下：  
![alt 图标](https://github.com/Zhao-BJ/LeetCodeGraphical/blob/main/%E7%AC%AC11%E7%AB%A0%20%E6%95%A3%E5%88%97%E8%A1%A8/sourcefile/T1TwoSum.png)

__C++ 解法：__
```C++  
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> m;
        for (int i = 0; i < nums.size(); ++i) {
            if (m.count(target - nums[i])) {
                return {i, m[target - nums[i]]};
            }
            m[nums[i]] = i;
        }
        return {};
    }
};  
```